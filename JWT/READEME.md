# JWT　　
JSON Web Tokens (JWTs) are a standardized format for transmitting cryptographically signed JSON data between systems. While they can contain any type of data, JWTs are commonly used to send user-related information ("claims") for authentication, session management, and access control.   

Unlike traditional session tokens, JWTs store all necessary data client-side, making them ideal for distributed websites where users interact with multiple back-end servers.
## JWT signature
The server that issues a JSON Web Token (JWT) generates its signature by hashing the header and payload, sometimes also encrypting the hash. This process uses a secret signing key, allowing servers to verify that the token's data hasn't been altered since issuance.

- Changing any part of the header or payload causes the signature to mismatch.
- Without the server's secret signing key, it is impossible to create a correct signature for the token.

## JWT Attacks
JWT attacks involve an attacker sending modified JWTs to a server to achieve malicious objectives. The primary goal is usually to bypass authentication and access controls by impersonating an already authenticated user.

## JWT header parameter injections
According to the JWS specification, only the `alg` header parameter is mandatory, but JWT headers (or JOSE headers) often include other parameters that are of particular interest to attackers:

- **jwk (JSON Web Key)**: Embeds a JSON object representing the key.
- **jku (JSON Web Key Set URL)**: Provides a URL for servers to fetch a set of keys containing the correct key.
- **kid (Key ID)**: Identifies the correct key when multiple keys are available.

These user-controllable parameters inform the server which key to use for verifying the JWT's signature. Attackers can exploit these parameters to inject modified JWTs that are signed with their own arbitrary key rather than the server's secret key.
### Labs Portswigger
1. JWT authentication bypass via unverified signature  
>Simply change "sub" to administrator


2. JWT authentication bypass via flawed signature verification  
>None algorithm (set "alg": "none" and delete signature part)


3. JWT authentication bypass via weak signing key  
※Weak key is easily detected by Burp Suite Passive Scanner  
>Crack signing key with hashcat: ```hashcat -m 16500 -a 0 <full_jwt> /usr/share/wordlists/rockyou.txt```


4. JWT authentication bypass via jwk header injection  
>4.1 Go to JWT Editor Keys - New RSA Key - Generate  
>4.2 Get Request with JWT token - Repeater - JSON Web Token tab - Attack (at the bottom) - Embedded JWK - Select your previously generated key - OK  


5. JWT authentication bypass via jku header injection  
>5.1 JWT Editor Keys - New RSA Key - Generate - right-click on key - Copy Public Key as JWK  
>5.2 Go to your exploit server and paste the next payload in Body:  
```
{
    "keys": [

    ]
}
```
>5.3 In "keys" section paste your previously copied JWK:  
```
{
    "keys": [
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "893d8f0b-061f-42c2-a4aa-5056e12b8ae7",
            "n": "yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw"
        }
    ]
}
```
>5.4 Back to our JWT, replace the current value of the kid parameter with the kid of the JWK that you uploaded to the exploit server.  
>5.5 Add a new jku parameter to the header of the JWT. Set its value to the URL of your JWK Set on the exploit server.  
>5.6 Change "sub" to administrator  
>5.7 Click "Sign" at the bottom of JSON Web Token tab in repeater and select your previously generated key  


6. JWT authentication bypass via kid header path traversal  
>6.1 JWT Editor Keys - New Symmetric Key - Generate - replace the value of "k" parameter to AA== - OK  
>6.2 Back to our JWT, replace "kid" parameter with ../../../../../dev/null  
>6.3 Change "sub" to administrator  
>6.4 Click "Sign" at the bottom of JSON Web Token tab in repeater and select your previously generated key  
