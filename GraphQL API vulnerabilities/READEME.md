# GraphQL API vulnerabilities
[What is GraphQL?](https://portswigger.net/web-security/graphql/what-is-graphql)

GraphQL vulnerabilities often stem from implementation and design flaws. 
One such flaw is leaving the **introspection feature** active, which allows attackers to query the API and discover its schema.

GraphQL attacks typically involve sending malicious requests to obtain data or perform unauthorized actions. 
These attacks can have significant impacts, particularly if the attacker can elevate privileges (e.g., gaining admin access) 
through query manipulation or a Cross-Site Request Forgery (CSRF) exploit. 
Additionally, poorly secured GraphQL APIs can lead to information disclosure vulnerabilities, exposing sensitive data.

## Finding GraphQL endpoints 
- **Universal queries**  
  When you send the query `query{__typename}` to any GraphQL endpoint, the response will include the string `{"data": {"__typename": "query"}}`. This is known as a **universal query**, and it's a useful tool to check whether a URL corresponds to a GraphQL service.
  
  This query works because every GraphQL endpoint has a reserved field called `__typename`, which returns the type of the queried object as a string.

- **Common endpoint names**  
  GraphQL services often have similar endpoint suffixes. When testing for GraphQL endpoints, you can send universal queries (like `query{__typename}`) to the following common locations:
  ```
  /graphql
  /api
  /api/graphql
  /graphql/api
  /graphql/graphql
  ```
  If these don't yield a GraphQL response, you can also try appending `/v1` to the path (e.g., `/graphql/v1`).

- **Request methods**  
  When trying to find GraphQL endpoints, it's important to test with different request methods. Best practice is for production GraphQL endpoints to only accept POST requests with a content-type of `application/json`, as this helps prevent CSRF vulnerabilities. However, some endpoints may also accept alternative methods, such as GET requests or POST requests with a content-type of `x-www-form-urlencoded`.
  
  If you can't locate the GraphQL endpoint with POST requests to common URLs, try sending the universal query using alternative HTTP methods.

- **Initial testing**  
  Once you've discovered the GraphQL endpoint, you can send test requests to gain insights into how it functions. If the endpoint powers a website, explore the web interface using Burp's browser and review the HTTP history to analyze the GraphQL queries that are being sent.

## **Exploiting unsanitized arguments**  
Once you've explored the GraphQL endpoint, you can start looking for vulnerabilities. A good place to begin is by testing **query arguments**.

If the API allows access to objects through arguments, it may be vulnerable to access control vulnerabilities.

For example, the query below requests a product list for an online shop: 
```
 #Example product query

    query {
        products {
            id
            name
            listed
        }
    }
```
The product list returned contains only listed products. 
```
#Example product response

    {
        "data": {
            "products": [
                {
                    "id": 1,
                    "name": "Product 1",
                    "listed": true
                },
                {
                    "id": 2,
                    "name": "Product 2",
                    "listed": true
                },
                {
                    "id": 4,
                    "name": "Product 4",
                    "listed": true
                }
            ]
        }
    }

```
From this information, we can infer the following:

>Products are assigned a sequential ID.  
Product ID 3 is missing from the list, possibly because it has been delisted.

By querying the ID of the missing product, we can get its details, even though it is not listed on the shop and was not returned by the original product query. 
```
    #Query to get missing product

    query {
        product(id: 3) {
            id
            name
            listed
        }
    }

    #Missing product response

    {
        "data": {
            "product": {
            "id": 3,
            "name": "Product 3",
            "listed": no
            }
        }
    }
```

## Discovering schema information 



## Bypassing GraphQL introspection defenses 


## Bypassing rate limiting using aliases 





## GraphQL CSRF
CSRF vulnerabilities can occur when a GraphQL endpoint does not validate the content type of incoming requests and does not implement CSRF tokens.

POST requests with a content type of `application/json` are generally secure against CSRF, provided the content type is validated. In such cases, an attacker cannot force a victim's browser to send a forged request, even if the victim visits a malicious site.

However, if the endpoint accepts alternative methods, such as GET requests or POST requests with a content type of `x-www-form-urlencoded`, the victimâ€™s browser can send these requests, leaving users vulnerable to attack. In such scenarios, attackers could craft exploits to send malicious requests to the API.

### Labs Portswigger
1. Accessing private GraphQL posts
2. Accidental exposure of private GraphQL fields
3. Finding a hidden GraphQL endpoint
4. Bypassing GraphQL brute force protections
5. Performing CDRF exploits over GraphQL







