# GraphQL API vulnerabilities

[What is GraphQL?](https://portswigger.net/web-security/graphql/what-is-graphql)  

GraphQL vulnerabilities often stem from implementation and design flaws. 
One such flaw is leaving the **introspection feature** active, which allows attackers to query the API and discover its schema.

GraphQL attacks typically involve sending malicious requests to obtain data or perform unauthorized actions. 
These attacks can have significant impacts, particularly if the attacker can elevate privileges (e.g., gaining admin access) 
through query manipulation or a Cross-Site Request Forgery (CSRF) exploit. 
Additionally, poorly secured GraphQL APIs can lead to information disclosure vulnerabilities, exposing sensitive data.

## Finding GraphQL endpoints 
- **Universal queries**  
  When you send the query `query{__typename}` to any GraphQL endpoint, the response will include the string `{"data": {"__typename": "query"}}`. This is known as a **universal query**, and it's a useful tool to check whether a URL corresponds to a GraphQL service.
  
  This query works because every GraphQL endpoint has a reserved field called `__typename`, which returns the type of the queried object as a string.

- **Common endpoint names**  
  GraphQL services often have similar endpoint suffixes. When testing for GraphQL endpoints, you can send universal queries (like `query{__typename}`) to the following common locations:
  ```
  /graphql
  /api
  /api/graphql
  /graphql/api
  /graphql/graphql
  ```
  If these don't yield a GraphQL response, you can also try appending `/v1` to the path (e.g., `/graphql/v1`).

- **Request methods**  
  When trying to find GraphQL endpoints, it's important to test with different request methods. Best practice is for production GraphQL endpoints to only accept POST requests with a content-type of `application/json`, as this helps prevent CSRF vulnerabilities. However, some endpoints may also accept alternative methods, such as GET requests or POST requests with a content-type of `x-www-form-urlencoded`.
  
  If you can't locate the GraphQL endpoint with POST requests to common URLs, try sending the universal query using alternative HTTP methods.

- **Initial testing**  
  Once you've discovered the GraphQL endpoint, you can send test requests to gain insights into how it functions. If the endpoint powers a website, explore the web interface using Burp's browser and review the HTTP history to analyze the GraphQL queries that are being sent.

## **Exploiting unsanitized arguments**  
Once you've explored the GraphQL endpoint, you can start looking for vulnerabilities. A good place to begin is by testing **query arguments**.

If the API allows access to objects through arguments, it may be vulnerable to access control vulnerabilities.

For example, the query below requests a product list for an online shop: 
```
 #Example product query

    query {
        products {
            id
            name
            listed
        }
    }
```
The product list returned contains only listed products. 
```
#Example product response

    {
        "data": {
            "products": [
                {
                    "id": 1,
                    "name": "Product 1",
                    "listed": true
                },
                {
                    "id": 2,
                    "name": "Product 2",
                    "listed": true
                },
                {
                    "id": 4,
                    "name": "Product 4",
                    "listed": true
                }
            ]
        }
    }

```
From this information, we can infer the following:

>Products are assigned a sequential ID.  
Product ID 3 is missing from the list, possibly because it has been delisted.

By querying the ID of the missing product, we can get its details, even though it is not listed on the shop and was not returned by the original product query. 
```
    #Query to get missing product

    query {
        product(id: 3) {
            id
            name
            listed
        }
    }

    #Missing product response

    {
        "data": {
            "product": {
            "id": 3,
            "name": "Product 3",
            "listed": no
            }
        }
    }
```

## Discovering schema information 
The next step in testing the API is to gather information about the underlying schema. The most effective way to do this is by using **introspection queries**. Introspection is a built-in GraphQL function that allows you to query a server for details about the schema.

Using introspection helps you understand how to interact with a GraphQL API and can also reveal potentially sensitive information, such as description fields.

1. **Using introspection**  
To discover schema information using introspection, query the `__schema` field, which is accessible from the root type of all queries.
Similar to regular queries, you can specify the fields and structure of the response you want when executing an introspection query. For instance, you might request the response to include only the names of available mutations.

2. **Probing for introspection**  
It is considered best practice to disable introspection in production environments, but this advice is not always adhered to.  
You can check for introspection using the following simple query. If introspection is enabled, the response will return the names of all available queries.
  ```
  #Introspection probe request
  
      {
          "query": "{__schema{queryType{name}}}"
      }
  ```
3. **Running a full introspection query**  
The next step is to execute a full introspection query against the endpoint to gather comprehensive information about the underlying schema.  
The example query below retrieves complete details on all queries, mutations, subscriptions, types, and fragments.
  <details open><summary>Example</summary>
    
  ```
      #Full introspection query
  
      query IntrospectionQuery {
          __schema {
              queryType {
                  name
              }
              mutationType {
                  name
              }
              subscriptionType {
                  name
              }
              types {
               ...FullType
              }
              directives {
                  name
                  description
                  args {
                      ...InputValue
              }
              onOperation  #Often needs to be deleted to run query
              onFragment   #Often needs to be deleted to run query
              onField      #Often needs to be deleted to run query
              }
          }
      }
  
      fragment FullType on __Type {
          kind
          name
          description
          fields(includeDeprecated: true) {
              name
              description
              args {
                  ...InputValue
              }
              type {
                  ...TypeRef
              }
              isDeprecated
              deprecationReason
          }
          inputFields {
              ...InputValue
          }
          interfaces {
              ...TypeRef
          }
          enumValues(includeDeprecated: true) {
              name
              description
              isDeprecated
              deprecationReason
          }
          possibleTypes {
              ...TypeRef
          }
      }
  
      fragment InputValue on __InputValue {
          name
          description
          type {
              ...TypeRef
          }
          defaultValue
      }
  
      fragment TypeRef on __Type {
          kind
          name
          ofType {
              kind
              name
              ofType {
                  kind
                  name
                  ofType {
                      kind
                      name
                  }
              }
          }
      }
  ```
  </details>

## Bypassing GraphQL introspection defenses 
If you cannot run introspection queries on the API you are testing, try inserting a special character after the `__schema` keyword. When developers disable introspection, they may use a regex to block the `__schema` keyword, but certain characters like spaces, new lines, and commas might be ignored by GraphQL but not by flawed regex.

For example, if the developer only excluded `__schema{`, then the following introspection query might still be valid:
```
 #Introspection query with newline
    {
        "query": "query{__schema
        {queryType{name}}}"
    }
```
If this approach doesnâ€™t work, consider using a different request method, as introspection might only be disabled for POST requests. Try sending a GET request or a POST request with a content-type of `x-www-form-urlencoded`.

An example of an introspection probe sent via GET is shown below, with URL-encoded parameters:
```
# Introspection probe as GET request

    GET /graphql?query=query%7B__schema%0A%7BqueryType%7Bname%7D%7D%7D
```




## Bypassing rate limiting using aliases 
In GraphQL, objects typically cannot contain multiple properties with the same name. However, **aliases** allow you to bypass this restriction by explicitly naming the properties you want returned. This enables you to request multiple instances of the same type of object in a single request.

While **aliases** are designed to reduce the number of API calls, they can also be exploited to *brute force* a GraphQL endpoint. Many endpoints implement rate limiters to prevent such attacks, but some of these limiters track the number of HTTP requests rather than the number of operations performed on the endpoint. Since **aliases** allow multiple queries within a single HTTP message, they can circumvent these rate limiting mechanisms.

For example, a series of aliased queries might be used to check the validity of multiple store discount codes at once. This operation could potentially bypass rate limiting by consolidating many checks into a single HTTP request.
```
#Request with aliased queries

    query isValidDiscount($code: Int) {
        isvalidDiscount(code:$code){
            valid
        }
        isValidDiscount2:isValidDiscount(code:$code){
            valid
        }
        isValidDiscount3:isValidDiscount(code:$code){
            valid
        }
    }
```

## GraphQL CSRF
CSRF vulnerabilities can occur when a GraphQL endpoint does not validate the content type of incoming requests and does not implement CSRF tokens.

POST requests with a content type of `application/json` are generally secure against CSRF, provided the content type is validated. In such cases, an attacker cannot force a victim's browser to send a forged request, even if the victim visits a malicious site.

However, if the endpoint accepts alternative methods, such as GET requests or POST requests with a content type of `x-www-form-urlencoded`, the victimâ€™s browser can send these requests, leaving users vulnerable to attack. In such scenarios, attackers could craft exploits to send malicious requests to the API.

### Labs Portswiggerã€€ã€€
[Work with GraphQL in Burp](https://portswigger.net/burp/documentation/desktop/testing-workflow/working-with-graphql) 
1. Accessing private GraphQL posts
```
query {
    getBlogPost(id: 3) {
        id
        postPassword
    }

```

2. Accidental exposure of private GraphQL fields
```
query {
    getUser(id: Int!) {
        id
        password
        username
    }
}
```

3. Finding a hidden GraphQL endpoint




4. Bypassing GraphQL brute force protections



5. Performing CDRF exploits over GraphQL







