# RaceConditons
Race conditions are a common vulnerability related to business logic flaws. They occur when websites process requests concurrently without sufficient safeguards, causing multiple threads to interact with the same data simultaneously. This "collision" leads to unintended behavior, which attackers exploit by sending carefully timed requests during a vulnerable period known as the "**race window**."

An example is exploiting race conditions to repeatedly redeem a single-use gift card. The impact of such vulnerabilities varies based on the application and the functionality affected.

## Variations of attack on limit overruns race conditions
- Redeeming a gift card multiple times
- Rating a product multiple times
- Withdrawing or transferring cash in excess of your account balance
- Reusing a single CAPTCHA solution
- Bypassing an anti-brute-force rate limit

## Detecting and exploiting limit overrun race conditions
- Burp
  1. Identify a single-use or rate-limited endpoint
  2. Send multiple requests to this endpoint
- Turbo Intruder
  1. In request body, right-click and select Extensions > Turbo Intruder > Send to turbo intruder.
  2. From the drop-down menu, select template. e.g.):
  
  ```python
  def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                            concurrentConnections=1,
                            engine=Engine.BURP2
                            )
    
    # queue 20 requests in gate '1'
    for i in range(20):
        engine.queue(target.req, gate='1')
    
    # send all requests in gate '1' in parallel
    engine.openGate('1')

  ```










## Multi-endpoint race conditions







## Single-endpoint race conditions
Sending parallel requests with different values to a single endpoint can lead to significant race conditions. For example, a password reset mechanism that stores the user ID and reset token in the session is vulnerable. If two parallel password reset requests are sent from the same session but with different usernames, a collision may occur.

In this scenario, the session might end up containing the victim's user ID while sending a valid reset token to the attacker. The final state would look like:

![image](https://github.com/d41ki-3/PenTestCheatsheet/blob/main/Race%20conditions/file/race-conditions-password-reset-collision.png)
- session['reset-user'] = victim
- session['reset-token'] = 1234

The attacker gains access to the victimâ€™s account using the reset token sent to their session.

Email-based operations, such as email confirmation, are also prone to race conditions. Since emails are often sent in the background after the server responds to the client, race conditions are more likely.









## Time-sensitive attacks
Even if race conditions aren't present, using precise timing techniques can still uncover other vulnerabilities. For instance, high-resolution timestamps may be used in place of cryptographically secure random strings to generate security tokens.

In one example, if a password reset token is generated using a timestamp rather than a secure random string, it may be possible to trigger two password resets for different users with the same token. By carefully timing the requests, you could ensure both reset processes use the same timestamp, leading to token reuse.

### Labs Portswigger
1. Limit overrun race conditions
2. Bypassing rate limits via race conditions
3. Multi-endpoint race conditions
4. Single-endpoint race conditions
5. Exploiting time-sensitive vulnerabilities
