# RaceConditons
Race conditions are a common vulnerability related to business logic flaws. They occur when websites process requests concurrently without sufficient safeguards, causing multiple threads to interact with the same data simultaneously. This "collision" leads to unintended behavior, which attackers exploit by sending carefully timed requests during a vulnerable period known as the "**race window**."

An example is exploiting race conditions to repeatedly redeem a single-use gift card. The impact of such vulnerabilities varies based on the application and the functionality affected.


## Variations of attack on limit overruns race conditions
- Redeeming a gift card multiple times
- Rating a product multiple times
- Withdrawing or transferring cash in excess of your account balance
- Reusing a single CAPTCHA solution
- Bypassing an anti-brute-force rate limit


## Detecting and exploiting limit overrun race conditions
- Burp
  1. Identify a single-use or rate-limited endpoint
  2. Send multiple requests to this endpoint
- Turbo Intruder
  1. In request body, right-click and select Extensions > Turbo Intruder > Send to turbo intruder.
  2. From the drop-down menu, select template. e.g.):
  
  ```python
  def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                            concurrentConnections=1,
                            engine=Engine.BURP2
                            )
    
    # queue 20 requests in gate '1'
    for i in range(20):
        engine.queue(target.req, gate='1')
    
    # send all requests in gate '1' in parallel
    engine.openGate('1')

  ```

## Hidden multi-step sequences
https://portswigger.net/web-security/race-conditions#hidden-multi-step-sequences


### Methodology
To detect and exploit hidden multi-step sequences:
1. **Predict potential collisions**  
Asking yourself to reduce the number fo endpoint fllowing questions: 
    - Is this endpoint security critical?
    - Is there any collision potential?
    ![image](https://github.com/d41ki-3/PenTestCheatsheet/blob/main/Race%20conditions/file/race-conditions-collision-potential.png)
    > The second image is vulnerabble to be able to edit the same record with requests for two different users.
2. **Probe for clues**
    1. To recognize clues, you first need to benchmark how the endpoint behaves under normal conditions with Burp Repeater.
    2. Send group in parallel option.
    3. Just look for some form of deviation from what you observed during benchmarking.
3. **Prove the concept**  
Make sure you can still replicate the effects. 


## Multi-endpoint race conditions
When testing for multi-endpoint race conditions, it can be challenging to align the race windows for each request, even if all requests are sent simultaneously using the single-packet technique. The difficulty arises because each endpoint may handle the requests differently, and the timing for the race window may not perfectly overlap. As a result, even if the requests are dispatched at the same moment, the race window alignment might not be achieved, complicating the ability to exploit the race condition.

---
**Connection warming**  

Back-end connection delays generally do not disrupt race condition attacks, as they tend to affect parallel requests uniformly, maintaining their synchronization. To differentiate these delays from those arising from endpoint-specific factors, one effective method is to "`warming`" the connection with trivial requests. For instance, in Burp Repeater, you can initiate a tab group with a simple GET request to the homepage before sending your main requests in sequence using the "`Send group in sequence (single connection)`" option. If the initial request exhibits a longer processing time, but subsequent requests complete within a shorter timeframe, you can disregard the initial delay and proceed with your testing.

---
**Abusing rate or resource limits**  

If connection warming doesn't make any difference, there are various solutions to this problem.
Using Turbo Intruder, you can introduce a short client-side delay.

## Single-endpoint race conditions
Sending parallel requests with different values to a single endpoint can lead to significant race conditions. For example, a password reset mechanism that stores the user ID and reset token in the session is vulnerable. If two parallel password reset requests are sent from the same session but with different usernames, a collision may occur.

In this scenario, the session might end up containing the victim's user ID while sending a valid reset token to the attacker. The final state would look like:

![image](https://github.com/d41ki-3/PenTestCheatsheet/blob/main/Race%20conditions/file/race-conditions-password-reset-collision.png)
- session['reset-user'] = victim
- session['reset-token'] = 1234

The attacker gains access to the victimâ€™s account using the reset token sent to their session.

Email-based operations, such as email confirmation, are also prone to race conditions. Since emails are often sent in the background after the server responds to the client, race conditions are more likely.


## Time-sensitive attacks
Even if race conditions aren't present, using precise timing techniques can still uncover other vulnerabilities. For instance, high-resolution timestamps may be used in place of cryptographically secure random strings to generate security tokens.

In one example, if a password reset token is generated using a timestamp rather than a secure random string, it may be possible to trigger two password resets for different users with the same token. By carefully timing the requests, you could ensure both reset processes use the same timestamp, leading to token reuse.


### Labs Portswigger
1. Limit overrun race conditions
>Send the group of `POST /cart/coupon` requests in parallel.

2. Bypassing rate limits via race conditions
>2.1 In login function, confirm that the rate limit is enforced per-username rather than per-session.  
>2.2 In Burp Repeater, highlight the value of the `password` parameter in the `POST /login` request.
>2.3 Right-click and select `Extensions > Turbo Intruder > Send to turbo intruder.`  
>2.4 Select template and edit it.  
```python
def queueRequests(target, wordlists):

    # as the target supports HTTP/2, use engine=Engine.BURP2 and concurrentConnections=1 for a single-packet attack
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=1,
                           engine=Engine.BURP2
                           )
    
    # assign the list of candidate passwords from your clipboard
    passwords = wordlists.clipboard
    
    # queue a login request using each password from the wordlist
    # the 'gate' argument withholds the final part of each request until engine.openGate() is invoked
    for password in passwords:
        engine.queue(target.req, password, gate='1')
    
    # once every request has been queued
    # invoke engine.openGate() to send all requests in the given gate simultaneously
    engine.openGate('1')


def handleResponse(req, interesting):
    table.add(req)
```
>2.5 Copy the list of candidate passwords to your clipboard then, attack
 
3. Multi-endpoint race conditions
>3.1 Confirm that without the session cookie, you can only access an empty cart.  
>3.2 Send both the `POST /cart` and `POST /cart/checkout` request to Burp Repeater then, creating a new tab gropup.  
>3.3 Notice from the response times that the first request consistently takes significantly longer than the second one.  
>3.4 Keep one gift card in cart.Next, in Repeater, modify the POST /cart request in your tab group so that the productId parameter is set to value you want to expoit. Then, try sending the requests again, but this time in parallel.  

4. Single-endpoint race conditions


5. Exploiting time-sensitive vulnerabilities

