# RaceConditons
Race conditions are a common vulnerability related to business logic flaws. They occur when websites process requests concurrently without sufficient safeguards, causing multiple threads to interact with the same data simultaneously. This "collision" leads to unintended behavior, which attackers exploit by sending carefully timed requests during a vulnerable period known as the "**race window**."

An example is exploiting race conditions to repeatedly redeem a single-use gift card. The impact of such vulnerabilities varies based on the application and the functionality affected.

## Variations of attack on limit overruns race conditions
- Redeeming a gift card multiple times
- Rating a product multiple times
- Withdrawing or transferring cash in excess of your account balance
- Reusing a single CAPTCHA solution
- Bypassing an anti-brute-force rate limit

## Detecting and exploiting limit overrun race conditions
- Burp
  1. Identify a single-use or rate-limited endpoint
  2. Send multiple requests to this endpoint
- Turbo Intruder
  1. In request body, right-click and select Extensions > Turbo Intruder > Send to turbo intruder.
  2. From the drop-down menu, select template. e.g.):
  
  ```python
  def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                            concurrentConnections=1,
                            engine=Engine.BURP2
                            )
    
    # queue 20 requests in gate '1'
    for i in range(20):
        engine.queue(target.req, gate='1')
    
    # send all requests in gate '1' in parallel
    engine.openGate('1')

  ```

### Labs Portswigger
1. Limit overrun race conditions
2. Bypassing rate limits via race conditions
3. Multi-endpoint race conditions
4. Single-endpoint race conditions
5. Exploiting time-sensitive vulnerabilities
